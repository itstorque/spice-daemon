from pathlib import Path

# from file_interface import File
import spice_daemon as sd

class Simulation():
    
    OPT_CODES = {"reltol", "abstol"} # TODO: finish this!!
    
    def __init__(self, circuit_path, T=0, STEPS=0, params={}, opt_params={"reltol": 1e-6}, daemon_folder_loc=None, watchdog_delay=1):
        
        self.T     = T
        self.STEPS = STEPS
        
        self.params     = params
        self.opt_params = opt_params
        
        self.watchdog_delay = watchdog_delay
        
        self.circuit_path = Path(circuit_path)
        self.circuit_loc = self.circuit_path.parent.resolve()
        self.circuit_name = self.circuit_path.stem
        
        if daemon_folder_loc==None:
            daemon_folder_loc = self.circuit_loc
        
        self.daemon_files = Path(daemon_folder_loc) / ".spice-daemon-data"
        
        self.tran_file = sd.helpers.File(self.daemon_files / "trancmd.txt")
        
        self.modules = set()
        self.toolkits = set()
        
        # logfile generated by LTspice
        self.log_file = sd.helpers.File( self.circuit_loc / (self.circuit_name + ".log") ) # force_run_spice_if_fail was used before refactoring...
        
        # yaml definitions file
        self.def_file = sd.helpers.File( self.daemon_files / "spice-daemon.yaml" )
        
        # WatchDog watches files in self.watch_files for changes and runs a function whenever they are modified
        self.watch_files = {self.log_file, self.def_file}
        self.watchdog = None
        
    def update_tran_file(self):
        # Generates a tran file "trancmd.txt" in daemon_loc
        
        contents = f"""** GENERATED BY SPICE-DAEMON **\n
.param T {self.T}
.param STEPS {self.STEPS}
.param STEPSIZE {self.T/self.STEPS}\n\n"""

        for key, value in self.params.items():
            contents += f".param {key} {value}\n"

        for key, value in self.opt_params.items():
            contents += f".option {key} {value}\n"
        
        return self.tran_file.write(contents)
    
    def generate_modules(self):
        raise NotImplementedError
        
    def process_toolkits(self):
        raise NotImplementedError
    
    def add_module(self, module):
        
        if not isinstance(module, sd.helpers.Element):
            raise TypeError
        
        self.modules.add(module)
    
    def add_toolkit(self, toolkit):
        self.toolkits.add(toolkit)
        
    def clear_modules(self):
        self.modules = set()
        
    def clear_toolkits(self):
        self.toolkits = set()
        
    def add_module_from_def(self, module_type, params):
        
        for name in params:
        
            module = eval(f"sd.modules.{module_type}()")
            
            module.load_data(name, params[name])
            
            self.add_module(module)
            
            print(self.modules)
        
    def add_toolkit_from_def(self, name, params):
        
        # generator = eval(key + "()")
        pass
        
    def add_from_def_file(self):
        
        source_data = self.def_file.load_yaml()
        
        for type in source_data.keys():
            
            for entry in source_data[type].keys():
                
                value = source_data[type][entry]
            
                if type == "sim":
                    
                    # self.STEPS = source_data["sim"]["STEPS"]
                    # self.T = source_data["sim"]["T"]
                    
                    if entry == "STEPS":
                        self.STEPS = value
                        
                    elif entry == "T":
                        self.T = value
                        
                    elif entry in self.OPT_CODES:
                        self.opt_params[entry] = value
                        
                    else:
                        self.params[entry] = value
                    
                elif type == "modules":
                    
                    self.add_module_from_def(entry, value)
                    
                elif type == "toolkit":

                    self.add_toolkit_from_def(entry, value)
                    
                else:
                    raise KeyError
        
    def on_update(self, changed):
        print("UPDATE", changed)
        
        if self.def_file in changed:
            # reimport modules and toolkits
            
            self.clear_modules()
            self.clear_toolkits()
            
            self.add_from_def_file()
        
    def run_watchdog(self):
        if self.watchdog and self.watchdog.is_running(): return
        
        self.watchdog = sd.helpers.WatchDog(self.watch_files, self.on_update, delay=self.watchdog_delay)
        
        self.watchdog.watch()